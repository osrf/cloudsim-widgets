<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../elements/elements.html">

<dom-module id="cs-srcusermetrics">
  <style>
    :host {
      display: block;
      padding-top: 3em;
      @apply(--paper-font-common-base);
    }
    .horizontal {
      @apply(--layout-horizontal);
      @apply(--layout-center);
    }
    .space {
      @apply(--layout-flex);
    }
  </style>

  <template>

    <gz-resources
      id="metrics"
      url="[[portalurl]]"
      token="[[token]]"
      resourcename="metrics/simulator"
      on-resourcesupdated="_onGetAllMetrics"
    ></gz-resources>

    <gz-resources
      id="configs"
      url="[[portalurl]]"
      token="[[token]]"
      resourcename="metrics/config"
      on-resourcesupdated="_onGetAllConfigs"
    ></gz-resources>

    <!-- For getting user groups -->
    <gz-resources
      id="groups"
      url="[[authurl]]"
      token="[[token]]"
      resourcename="group"
      on-resourcesupdated="_onGroups"
    ></gz-resources>

    <div class="horizontal">

      <div class="space"></div>

      <template is="dom-if" if="{{isadmin}}">
          ADMIN
      </template>

      <div class="space"></div>
      <paper-material elevation="1">
        <div class="main-content">
          <h4 class="margintop">Instance-Hours metrics</h4>
          <div class="my-metrics">
            <template is="dom-repeat" items="[[balances]]">
              <div class="group-name">
                [[item.identity]]: Running [[item.running_time]] hours. Balance: [[item.balance]]
              </div>
            </template>
            <template is="dom-if" if="[[nogroups]]">
              <div class="group-name">
                No teams yet
              </div>
            </template>
          </div>
        </div>
      </paper-material>
      <div class="space"></div>

    </div>

  </template>

  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'cs-srcusermetrics',

      // Attached
      attached: function() {
        console.log('cs-srcusermetrics Attached!')
        let that = this
        if (that.token === "") {
          window.addEventListener('login', function() {
            that.$.groups.getAll();
            that.$.metrics.getAll();
          });
        }
        else {
          that.$.groups.getAll();
          that.$.metrics.getAll();
        }
      },

      // Callback when the current user has changed
      _currentUserChanged: function() {
        this.isadmin = this.currentuser === getConfig().admin
      },

      // Callback when all accessible metrics have been returned
      _onGetAllMetrics: function(e) {
        const metrics = e.detail
        this.metrics = metrics
        // let's now get the metric configs
        this.$.configs.getAll();
      },

      _onGetAllConfigs: function(e) {
        // Keep the enabled configs per team with the minimum number of allowed instance-hours
        let allConfigs = e.detail
        allConfigs = allConfigs.filter((config) => {
          // only keep enabled configs. And those whitelisting the user
          return !config.whitelisted && config.check_enabled
        })
        let grouped = {}      
        allConfigs.forEach((config) => {
          if (!grouped[config.identity]) {
            grouped[config.identity] = { max_instance_hours: Number.MAX_SAFE_INTEGER, identity: config.identity}
          } else {
            grouped[config.identity].max_instance_hours = Math.min(grouped[config.identity].max_instance_hours, config.max_instance_hours)
          }
        })
        this.configsMap = grouped
        this._createBalanceDetails()
      },

      _createBalanceDetails: function() { 
        let metricsMap = {}
        this.metrics.forEach((metric) => {
          metricsMap[metric.identity] = metric
          metric['balance'] = 'N/A'        
          metric['max_instance_hours'] = 'N/A'
        })
        // HACK
        //metricsMap['cloudsim@osrfoundation.org'] = { 'identity': 'cloudsim@osrfoundation.org', running_time: 5 }

        for (let configName in this.configsMap) {
          if (this.configsMap.hasOwnProperty(configName)) {
            let config = this.configsMap[configName]
            let metric = metricsMap[config.identity]
            if (metric) {
              metric['max_instance_hours'] = config.max_instance_hours
              metric['balance'] = config.max_instance_hours - metric.running_time
            } else {
              metricsMap[config.identity] = { 
                identity: config.identity, 
                running_time: 0, 
                max_instance_hours: config.max_instance_hours, 
                balance: config.max_instance_hours
              }
            }
          }
        }

        let tmpBalances = []
        for (let metricId in metricsMap) {
          if (metricsMap.hasOwnProperty(metricId)) {
            tmpBalances.push(metricsMap[metricId])
          }
        }
        this.balances = tmpBalances
      },

      // Callback when groups have been updated
      _onGroups: function() {
        this.groups = this.$.groups.resources
        this.nogroups = (this.groups.length == 0)
      },

      // Properties
      properties: {
        portalurl: {
          type: String,
          value: '',
          notify: true
        },
        // Auth server URL
        authurl: {
          type: String,
          value: '',
          notify: true
        },        
        // Authentication token from cloudsim-auth
        token: {
          type: String,
          value: '',
          notify: true
        },
        currentuser: {
          type: String,
          value: 'current user not set',
          notify: true,
          observer: '_currentUserChanged'
        },
        isadmin: {
          type: Boolean,
          value: false,
          notify: true
        },
        // Array of metrics for current user.
        metrics: {
          type: Array,
          value: [],
          notify: true
        },
        // Array of groups for current user.
        groups: {
          type: Array,
          value: [],
          notify: true
        },
        // Map with metric configs for current user.
        configsMap: {
          type: Object,
          value: {},
          notify: true
        }, 
        // Map with balance per user identity.
        balances: {
          type: Array,
          value: [],
          notify: true
        }
      },
    });
  })();
  </script>
</dom-module>
