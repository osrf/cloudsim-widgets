<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../elements/elements.html">

<dom-module id="cs-machinelist">
  <style>
    iron-list {
      padding-top: 64px;
      padding-bottom: 64px;
      --iron-list-items-container: {
        max-width: 90%;
        margin: auto;
        margin-bottom: 60px;
      }
    }
  </style>
  <template>

    <gz-simulatorq
      id="simulatorq"
      token={{token}}
      on-simulatorqupdated="onSimulatorqUpdated"
      url={{portalurl}}
    ></gz-simulatorq>

    <iron-list id="list" items="[[listitems]]" as="item" selection-enabled multi-selection>
      <template>
        <cs-machineitem
          itemid="[[item.id]]"
          stat="[[item.status]]"
          machine_ip="[[item.machine_ip]]"
          launch_date="[[item.launch_date]]"
          termination_date="[[item.termination_date]]"
          owner="[[item.owner.username]]"
          users="[[item.users]]"
          region="[[item.region]]"
          token="{{token}}"
          portalurl="{{portalurl}}"
          portalurl="{{portalurl}}"
        ></cs-machineitem>
      </template>
    </iron-list>

  </template>

  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'cs-machinelist',
      // Attached
      attached: function() {
        this.refresh()
        console.log('cs-machinelist widget attached!')
      },
      onSimulatorqUpdated: function(e) {
        if (e.detail.success)
        {
          this.updateList(e.detail.items);
        }
      },
      updateList: function(items) {
        this.sortByReverseLaunchDate(items);

        // The portal sends periodic updates even if there are no changes.
        // Check if there are status updates
        if (items.length == this.listitems.length)
        {
          let i = 0;
          while (i < items.length && items[i].status == this.listitems[i].status &&
              items[i].machine_ip == this.listitems[i].machine_ip)
          {
            ++i;
          }
          if (i == items.length)
            return;
        }

        // Make sure we're not calling this multiple times before the timeouts
        if (this.updateCount == this.updateTarget)
        {
          // Counters
          this.updateCount = 0;
          this.updateTarget = items.length;

          // Reset list
          this.splice("listitems", 0, this.listitems.length)

          // Push each item
          items.forEach(function(item, index){

            // Polymer issue #3682
            // https://github.com/Polymer/polymer/issues/3682
            // Consecutive updates only work asynchronously
            var that = this;
            setTimeout(function () {
              that.push('listitems', item);
              that.updateCount = that.updateCount + 1
            }, 100);

          }.bind(this));
        }
      },
      refresh() {
        this.$.simulatorq.tapGet();
      },
      sortByReverseLaunchDate: function(items) {
        items.sort(this.compareDates)
      },
      compareDates: function(a, b) {
        let aDate = new Date(a.launch_date)
        let bDate = new Date(b.launch_date)
        if (aDate < bDate)
            return 1;
        if (aDate > bDate)
            return -1;
        return 0;
      },
      properties: {
        portalurl: {
          type: String,
          value: 'https://localhost:4000',
          notify: true
        },
        token: {
          type: String,
          value: 'placeholder',
          notify: true
        },
        listitems: {
          type: Array,
          value: [],
          notify: true
        },
      },
    });
  })();
  </script>
</dom-module>
